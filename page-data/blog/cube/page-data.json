{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/cube","result":{"data":{"markdownRemark":{"html":"<p><strong>Update: Part 2 can be found Here:</strong><br>\n<strong><a href=\"/blog/CubeCAD\">Part 2: CAD and Machining</a></strong></p>\n<p>I thought since I'm now locked down because of the coronavirus that I would start a new project. I was quite fascinated with the <a href=\"https://idsc.ethz.ch/research-dandrea/research-projects/archive/cubli.html\">cubli</a>, it's amazing how well tuned it is, but the part that impressed me the most was how quickly it rejected disturbances and re-stabilized. Over the last few weeks I've gotten started, and I've gotten a good amount done, but this will be done in parts as it will be quite a long project.</p>\n<h2>The Motor</h2>\n<p>I thought I would start with the motor, since without that I couldn't really design much of anything outside of the Accelerometer/Gyro. This would probably be significantly easier with brushed motors, but I want to avoid that for a couple of reasons. First, the kind of brushed motors that I would need are very expensive because of the rare earth magnets used in them, and secondly, I think it would be cool to try building my own encoder for a brushless motor. </p>\n<h2>The Encoder</h2>\n<p>This is the first big hurdle in the project. Most (cheap) commercial ESC's use back EMF to determine the position of a brushless motor. That won't work here because I'm going to need to be able to drive the motor at slow speeds (you can't easily do this with backEMF because the slower a brushless motor goes the more current it takes to drive, making it very hard to detect the back EMF). I also need to reverse, which is a problem with back EMF because you obviously have to go slow before you reverse. For these reasons I went with Hall Sensors. They should detect the position of the rotor regardless of its speed, position, or direction, but they will be quite a bit harder to set up.</p>\n<h2>Design iterations</h2>\n<p>I created many different Hall boards before I settled on a final design, below are a few iterations:</p>\n<p><strong>Hallboard 1:</strong><br>\nhand drilled pcb meant that hall sensor position was not accurate. They were not easy to space 60 degrees apart, and were not equidistant from the motor. Hand positioning with an oscilloscope was tedius and results were still not very reliable. Used A3144 through hole hall sensors, which were not as sensitive as I was hoping.</p>\n<p><strong>Hallboard 2:</strong><br>\nSignificantly better than hallboard one, professionally fabricated PCB fixed the hole placement issue. Switching to new, more sensitive hall sensors (A1302) made results more reliable, however their placement along the outside of the motor meant that the magnetic field was still too weak to get reliable readings. The quiescent voltage of the sensors was 2.5V, and I observed readings from 2.1-2.65 volts depending on magnet polarity. I used external comparators to create a digital signal for the arduino, but I was worried that motor steps would be skipped because hall sensors would not detect the field.</p>\n<p><strong>Hallboard 3:</strong><br>\nFar better than the other two. I switched to SMD hall sensors after the position had been fine tuned, which made placement almost impossible to screw up. The Hall sensors were moved to the poles of the magnets where the field is stronger, as opposed to the outside of the motor. I switched to the newer A1304 sensors which seem to be much more sensitive as well, the quiescent voltage is 1.65v, and I observe a range from 0.1 volts to 3.2 volts, a much more comfortable range. I removed the comparators with the intention of using the Teensy's internal comparator (with the quiescent voltage on the AREF pin), however it works so well as is that I don't think that's necessary.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; margin-left:0\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/2c99f5a22b24d567f95303d7b07548e4/e9712/encoder_combined.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAFABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAIDBP/EABYBAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAAB2RNSwH//xAAXEAEBAQEAAAAAAAAAAAAAAAABAhEA/9oACAEBAAEFAgdkWSc7/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGBAAAwEBAAAAAAAAAAAAAAAAAAEREjL/2gAIAQEABj8CtLp1nTP/xAAbEAACAgMBAAAAAAAAAAAAAAABEQBBIWFxgf/aAAgBAQABPyEBhnVR/KKrkKGPcuf/2gAMAwEAAgADAAAAEHg//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxAAAgMAAwAAAAAAAAAAAAAAAREAMUEhcYH/2gAIAQEAAT8QML+qgOorO00A5YyIBIeBD0if/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"encoder image not found\"\n        title=\"encoder image not found\"\n        src=\"/static/2c99f5a22b24d567f95303d7b07548e4/c60e9/encoder_combined.jpg\"\n        srcset=\"/static/2c99f5a22b24d567f95303d7b07548e4/37402/encoder_combined.jpg 200w,\n/static/2c99f5a22b24d567f95303d7b07548e4/4cda9/encoder_combined.jpg 400w,\n/static/2c99f5a22b24d567f95303d7b07548e4/c60e9/encoder_combined.jpg 800w,\n/static/2c99f5a22b24d567f95303d7b07548e4/e9712/encoder_combined.jpg 870w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>  </p>\n<h2>Testing on the oscilloscope</h2>\n<p>Before I ran the motor, I used a different motor to spin it up, with the oscilloscope connected to two of its phases. By using a different motor to spin the first, you can view nothing but the back EMF, which is much easier than just using one motor.</p>\n<p>Here is an example of the output of middle hall sensor (hall sensor on bottom, EMF on top). The middle one should be inverted in a 12N14P motor, meaning low back EMF should correspond to high on the sensor.</p>\n<p>Heres a picture of what that looks like:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 443px; margin-left:0\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/10fb31d0e5c575ead21eaeef70b1a3d5/f4938/oscilloscope-encoder.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 76.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAIDBAX/xAAVAQEBAAAAAAAAAAAAAAAAAAADBP/aAAwDAQACEAMQAAABy3WS2emALf/EABsQAAICAwEAAAAAAAAAAAAAAAECABMDEiEx/9oACAEBAAEFAlx7SmFeowAth9//xAAYEQACAwAAAAAAAAAAAAAAAAAAIQIRE//aAAgBAwEBPwGWloZ//8QAGBEAAwEBAAAAAAAAAAAAAAAAAAECERL/2gAIAQIBAT8BnjBqD//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABoQAAMBAAMAAAAAAAAAAAAAAAABESExUWH/2gAIAQEAAT8h2cFeEmQ9UjofcP/aAAwDAQACAAMAAAAQB+//xAAXEQEBAQEAAAAAAAAAAAAAAAABACFB/9oACAEDAQE/EGHxGL//xAAXEQEBAQEAAAAAAAAAAAAAAAABABFB/9oACAECAQE/ECubQ3//xAAdEAEAAgICAwAAAAAAAAAAAAABESEAUTGRQWGx/9oACAEBAAE/EACGY3Ot4xMX187xKymKxRkrSbPODNvc++B6w2RJNOf/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"oscilloscope image not found\"\n        title=\"oscilloscope image not found\"\n        src=\"/static/10fb31d0e5c575ead21eaeef70b1a3d5/f4938/oscilloscope-encoder.jpg\"\n        srcset=\"/static/10fb31d0e5c575ead21eaeef70b1a3d5/37402/oscilloscope-encoder.jpg 200w,\n/static/10fb31d0e5c575ead21eaeef70b1a3d5/4cda9/oscilloscope-encoder.jpg 400w,\n/static/10fb31d0e5c575ead21eaeef70b1a3d5/f4938/oscilloscope-encoder.jpg 443w\"\n        sizes=\"(max-width: 443px) 100vw, 443px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>After that, I used the following code just to verify that it was all working nicely, this is the output as I rotate the motor by hand.</p>\n<p>This was harder than I expected to set up, so I figured I'd go through the problems I had in case anyone is doing something similar.</p>\n<ol>\n<li>I started this by milling PCBs on a CNC machine, but using through hole components meant that I couldn't exactly align the hall sensors every time. This offset caused my controller to switch magnets at (slightly) incorrect times, leading to a huge increase in heat as well as increased current draw. This was fixed by using SMD components. Applying solder paste and reflowing all the components onto the board made a huge difference in heat and current draw.</li>\n<li>My power supply was insufficient. I have a 30V 5A max variable power supply that I was testing on, however I noticed the power to the microcontroller was dipping significantly when the motor was running slower. This led to the microcontroller browning out and outputting insufficient voltage to the gates, only partially opening the MOSFETS and causing one to heat up very quickly and explode. This was fixed by testing on a LIPO battery, which has much higher burst currents and allows me to slow the motor much more without excess heat.</li>\n<li>To test, I simply de-soldered the Atmega8a chip on the ESC and soldered my own wires to the pins that controlled the MOSFETS (more on this later). This allowed me to control the motor without building my own ESC, but it is not very clean. I may attempt to build my own ESC for this later on. The advantage of this however is that if it does not work, you know that the problem is with your setup, and not the ESC itself.</li>\n</ol>\n<h2>The ESC</h2>\n<p>As I said earlier, I used a multimeter to determine which pins of the Atmega8a were controlling the MOSFETS, and soldered my own wires to them to control the ESC externally. This is what that setup looks like:</p>\n<p>This was my first attempt soldering on something this small, the wire was too long and I had a hard time getting a clean joint, so you can see scorch marks on the board.\nHere's the fully wired up ESC:  </p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; margin-left:0\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/3ab6208aae1c171107cce427b78581d6/f9f52/esc-closeup-combined.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAIABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAEDBP/EABYBAQEBAAAAAAAAAAAAAAAAAAACA//aAAwDAQACEAMQAAABzQTpeD//xAAaEAABBQEAAAAAAAAAAAAAAAABAAIREhMh/9oACAEBAAEFAoFOF2i//8QAFREBAQAAAAAAAAAAAAAAAAAAAhD/2gAIAQMBAT8BU//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABcQAAMBAAAAAAAAAAAAAAAAAAARMQH/2gAIAQEABj8CprKz/8QAGhAAAgIDAAAAAAAAAAAAAAAAAAERIUFhcf/aAAgBAQABPyFQWK1lFZOWzZ//2gAMAwEAAgADAAAAEH/f/8QAFxEAAwEAAAAAAAAAAAAAAAAAAAERIf/aAAgBAwEBPxDCUIf/xAAWEQEBAQAAAAAAAAAAAAAAAAAAETH/2gAIAQIBAT8Q1H//xAAbEAEAAQUBAAAAAAAAAAAAAAABEQAhMUFRYf/aAAgBAQABPxC04BhRO7ZrAHQCQLaoETOcgnnfK//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Missing Image\"\n        title=\"Missing Image\"\n        src=\"/static/3ab6208aae1c171107cce427b78581d6/c60e9/esc-closeup-combined.jpg\"\n        srcset=\"/static/3ab6208aae1c171107cce427b78581d6/37402/esc-closeup-combined.jpg 200w,\n/static/3ab6208aae1c171107cce427b78581d6/4cda9/esc-closeup-combined.jpg 400w,\n/static/3ab6208aae1c171107cce427b78581d6/c60e9/esc-closeup-combined.jpg 800w,\n/static/3ab6208aae1c171107cce427b78581d6/f9f52/esc-closeup-combined.jpg 944w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>The ESC also has an UBEC which I am using to power the arduino, however I am going to change this because I don't want the same thing to happen to the MOSFETs if the power through the UBEC drops again. </p>\n<h2>State of the project</h2>\n<p>Currently, I am able to control the speed of the motor. I can make it go slow, fast, and in reverse. This is a significant part of the project so hopefully I'll be able to get working on some code soon.</p>\n<p>For now, this is the roadmap for the project:</p>\n<h3>Future</h3>\n<ul>\n<li>Machine the Flywheel, Faceplate and Mounts</li>\n<li>Simulate the Initial \"pop-up\" of the Cube</li>\n<li>Add Accelerometers/Gyroscopes</li>\n<li>Software, PID/Kalman Filter</li>\n</ul>\n<h3>Completed</h3>\n<ul>\n<li>Design and Fab Hall Sensor Board</li>\n<li>Control the ESC from the Teensy 3.5</li>\n</ul>\n<p>With the Motor and Encoder working, it's time to design the body of the cube<br>\n<a href=\"/blog/CubeCAD\">Part 2: CAD and Machining</a></p>","frontmatter":{"date":"May 02, 2019","path":"/blog/cube","title":"Reaction Wheel Cube"}}},"pageContext":{}},"staticQueryHashes":[]}